<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../favicon.ico">

    <title>Dante Tam</title>

		<script src="../../dist/js/tether.min.js"></script>
		
    <!-- Custom styles for this template -->
    <link href="writings.css" rel="stylesheet">
		
		<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet" />
		<link href="https://cdn.datatables.net/plug-ins/1.10.7/integration/bootstrap/3/dataTables.bootstrap.css" rel="stylesheet" />
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<script src="https://cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script>
		<script src="https://cdn.datatables.net/plug-ins/1.10.7/integration/bootstrap/3/dataTables.bootstrap.js"></script>
		
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <nav class="navbar navbar-intro navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
						<span class="icon-bar"></span>
          </button>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav navbar-intro">
					  <li><a href="../writings.html">Writings</a></li>
						<li class="active"><a href="./java1-0.html">Introductions</a></li>
            <li><a href="./java1-1.html">OOP</a></li>
            <li><a href="./java1-2.html">Software Eng., Data</a></li>
						<li><a href="./java1-3.html">Trees</a></li>
						<li><a href="./java1-4.html">Hashing, Heaps</a></li>
						<li><a href="./java1-5.html">Graphs</a></li>
						<li><a href="./java1-6.html">Sorts</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
		
    <div class="container">

      <div class="intro">
        <h1>Java 0: Introductions</h1>
        <p class="lead">
					<i>From humble beginnings...</i><br>
				</p>
      </div>
			
			<div class="tutorial-text">
        A quick tutorial to get you up to speed in being comfortable writing OOP<br>
				and creating data structures. Prior basic experience is assumed.<br>
				<br>
				In Java, everything must be contained within a class.<br>
				A class represents a set of members and functions (methods).<br>
				Also, the language requires that every variable to be of a certain type.<br>
				
<pre>
//A comment. 
/*
A multi-line comment.
*/

public class HelloWorld { //A class declaration.
	public static void main(String[] args) { //A method declaration within the class.
		System.out.println("Hello world!");
	}
}

//To save space and time, assume all code not within classes runs correctly.
</pre>
				For now, do not be concerned with the keywords <code>public</code> and <code>static</code>.<br>
				The <code>void</code> modifier declares that the function returns nothing, takes in an<br>
				input of type <code>String[]</code>, while the name of the function is "main".<br>
				The method <code>main(String[] args)</code> is used as an entry point for the program.<br>
				<br>
				Java requires all functions to declare a return type, and all variables to be of<br>
				a certain type. There are primitives, which represent one fundamental item,<br>
				and objects, which are defined in class files. The important primitives:<br>
				
				<table class="table" cellspacing="0" width="100%">
					<thead>
						<tr>
							<th>Primitive Name</th>
							<th>Symbol</th>
							<th>Usage</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Boolean<td>
							<td><code>boolean</code></td>
							<td>Represents true or false</td>
						</tr>
						<tr>
							<td>Character<td>
							<td><code>char</code></td>
							<td>Represents a single Unicode character</td>
						</tr>
						<tr>
							<td>Integer<td>
							<td><code>int</code></td>
							<td>Whole numbers from -2,147,483,648 to +2,147,483,647</td>
						</tr>
						<tr>
							<td>Float<td>
							<td><code>float</code></td>
							<td>Floating point numbers (allows decimals) from 1.4E-45 to 3.4E+38</td>
						</tr>
						<tr>
							<td>Double<td>
							<td><code>double</code></td>
							<td>Floating point numbers (allows decimals) from 4.9E-324 to 1.8E+308</td>
						</tr>
					</tbody>
				</table>
				
				Let's introduce a few more fundamental types.<br>
				<br>
				In Java, <code>null</code> represents the absence of something. Note that the return<br>
				type of a function that does not return is <code>void</code>, <b>NOT</b> <code>null</code>. <code>null</code> can be used<br>
				to return nothing from a function that returns an Object.<br>
				<br>
				The first non-primitive introduced will be the <code>String</code> class.<br>
				A string represents a word, or a text of characters, or just any collection of symbols.<br>
				A string is immutable; it cannot be changed after creation.<br>
				<code>String</code> has many methods for manipulation.
				<br>
				Java math and relation operators are the standard ones.<br>
				<code>+,-,*,/,%(modulus),^(exponents for integers only),&gt;=,&lt;=,&gt;,&lt;,==,!=,&&(and),||(or),!(not)</code><br>
				<br>
				Generally, Java is pass-by-value, meaning that a <b>COPY</b> of a primitive is passed in.<br>
				When passing in objects, the object itself should be modified, not the pointer.<br>
				
<pre>
String manipulate(String obj) {
	String temp = obj;
	obj = null;
	obj = temp + "?";
	return temp + "!";
}

String mystery(String obj) {
	System.out.println(obj.replace('r','.'));
}

String temp = "Hodor";  //Note that this is the same as -> new String("Hodor")
manipulate(temp);
System.out.println(temp); //"Hodor"
System.out.println(manipulate(temp)); //"Hodor!"
mystery(temp); //"Hodo."
System.out.println(temp); //"Hodor"
</pre>
				
				Arrays holding any other type, including objects and other arrays, can be declared.<br>
				Arrays need either space allocated or an inline array {...} that sets the elements.<br> 
				The length of an array is found by <code>array.length</code>.<br>
				
<pre>
String[] sentence = new String[10];
sentence[0] = "First";
sentence[9] = "Last";
String[] otherSentence = {"Ook.", "Ook.", "Ook!", "Ook?"};
String[][] paragraph = {sentence, otherSentence};
</pre>

				Note how this array below can be accessed through a function.<br>
				This is generally the pattern of how to modify an object, when it is passed by value.<br>
				
<pre>
public static void manipulate(int[] obj) {
	obj[0] = 0;
}

int[] a = {3,2,1};
System.out.println(a[0]); //3
manipulate(a);
System.out.println(a[0]); //0
</pre>				
				
				Now that we have the important primitives down, we can create the "first" class.<br>
				A class is simply a collection of variables and methods. It is like a blueprint<br>
				An instance is an object created according to the class blueprint.<br>
				A constructor is an optional function with the same name of the class and no return modifier.<br>
				Its task is to initialize values and do anything required when a new object is created.
				
<pre>
//Here we define the class. We declare it.
class Student {
	double stressFactor = 1.0;
	int year;
	Student(int y) { //Constructor
		year = y;
	}
	void promote() {
		year = year + 1;
	}
}

//Here we're going to create an instance of the class.
Student namelessEntity = new Student(2019);
namelessEntity.promote();
System.out.println(namelessEntity.year); //2020
</pre>
				
				Pointers have similar behavior for primitives and objects.<br>
				Primitives and objects are passed by value. There is a subtle distinction.<br>
				
<pre>
void promoteTwice(Student s) {
	s.year = s.year + 2;
}

int a = 5;
int b = a;
System.out.println(a + " " + b); //"5 5"
a = 4;
System.out.println(a + " " + b); //"4 5"

//From the previous example
Student one = new Student(2015);
Student two = one;
System.out.println(one.year + " " + two.year); //"2015 2015"
one = new Student(2020);
System.out.println(one.year + " " + two.year); //"2020 2015"

two = one;
System.out.println(one.year + " " + two.year); //"2020 2020"
promoteTwice(one);
System.out.println(one.year + " " + two.year); //"2022 2022"
</pre>

				In the first block, we see that primitives were clearly passed by value.<br>
				In the second block, the two pointers once referred to the same <code>Student</code>,<br>
				but then they pointed to two separate objects, whereas in the third case, the function<br>
				<code>promoteTwice(Student s)</code> modified one object that both pointers were pointing at.<br>
				<br>
				Let's define more control. The syntax for a conditional statement:<br>

<pre>
if (booleanExpression) {
	//execute this block of code within if booleanExpression is true
}
</pre>				

				Note that <code>null</code> is not a proper boolean statement. Also, <b>null != false</b>.<br>
				A null check is done to see whether an object exists such as <code>if (obj != null) {/*...*/}</code>
				
<pre>
if (b1) {
	//execute this block of code within if b1 is true, skip to #end
} else if (b2) {
	//execute given b2 == true, skip to #end
} else if (b3) {
	//execute given b3 == true, skip to #end
} else {
	//execute if we haven't skipped out yet, skip to #end
}
//#end

if (b1) {
	//execute this block of code within if b1 is true
} 
if (b2) {
	//execute given b2 == true
} 
if (b3) {
	//execute given b3 == true, skip to #end
} else {
	//execute if b3 == false, skip to #end
}
#end
</pre>
				
				In Java, there are three main loops: for, while, and do-while.<br>
				A for-loop runs based on some condition.<br>
				
<pre>
/*
for (declare variables here; condition; do something at the end of the loop) {/*...*/}
*/

for (int i = 0; i &lt; 10; i++) {
	System.out.println(i); //0,1,2,...,9
}

int i = 0;
for (; i != 5; i++) {
	System.out.println(i); //0,1,2,3,4
}

for (int i = 0; i &lt; 10; i++) {
	for (int j = 0; j &lt;= i; j++) {
		System.out.println(j); //0,0,1,0,1,2,...,7,8,9 
	}
}
</pre>

				While loops only run based on condition. The first type of while loop<br>
				checks the condition at the beginning, and executes once if true.<br>
				
<pre>
boolean isPrime(int n) {
	/* implementation not shown */
	//This hiding is very common on tests.
}	

int i = 14;
//will print 14, 15, 16, checks that isPrime(17) is true, will stop
while (!isPrime(i)) {
	System.out.println(i);
	i++;
}
</pre>
				
				A do-while loop checks the condition at the end of the block.<br>
				It is guaranteed to run once. (Why?)<br>

<pre>
//will print 14, 15, 16, checks that isPrime(17) is true, will stop
i = 14;
do {
	System.out.println(i);
	i++;
} while(!isPrime(i)); //Note the semicolon
</pre>				

				A few more bits of control: <code>return</code>, <code>continue</code>, <code>break</code>.<br>
				<code>return</code> will return out of a function with the correct type. It ends the function.<br>
				<code>continue</code> will skip an iteration of the loop it is placed in.<br>
				<code>break</code> will immediately end the current loop it is in. It can only end one loop.<br>

<pre>
int countTo100() {
	int n = 1;
	while (true) do {
		n++;
		if (n != 100) {continue;}
		if (n == 100) {break;}
	}
	return n;
	//Code here is "dead code". Most compilers do not allow dead code.
}
</pre>				
	
				Lastly, we'll define one last important keyword: <code>static</code>.<br>
				<code>static</code> is used in two contexts: to show a single variable shared by all<br>
				instances of the class, and that class functions do not rely on the instance's own data.<br>
				Since static members are not chained to a single instance, they can be called directly from the class.<br>
				Note that static functions can only use its own static functions and members. (Why?)<br>
				
<pre>
class DataSet {
	static double e = 2.718;
	
	static int factorial(int n) {
		int product = 1;
		for (int i = 1; i &lt;= n; i++) {
			product = product * i;
		}
		return product;
	}
	
	static double letsDoSomeArithmetic(double[] data) {
		double series = 0;
		for (int i = 0; i &lt; data.length; i++) {
			double sum = e*data[i]/factorial(i);
			series = series + sum;
		}
		return series;
	}
}

double[] a = {1,2,3,4,5};
double b = DataSet.letsDoSomeArithmetic(a);
</pre>
				
				Here we'll provide a recap of all the syntax covered, for convenience.
				
<pre>
class Cafe {
	static String chainName = "Kama O Deli"; 
	String cafeName;
	
	Cafe(String name) {
		cafeName = name;
	}

	String[] orders;
	
	void placeOrder(String ord) {
		String[] copy = new String[orders.length];
		for (int i = 0; i &lt; orders.length; i++) {
			copy[i] = orders[i];
		}
		orders[orders.length] = ord;
		orders = copy;
	}
	
	String takeFirstOrder() {
		int i = 0;
		while (true) {
			if (i &gt;= orders.length) {
				return null; //Note a function that returns an Object or its subclass can return null
			}
			if (orders[i] != null) {
				break;
			}
		}
		String temp = orders[i];
		orders[i] = null; 
		return temp;
	}
	
	static String getChainName() {
		String temp = chainName + "!";
		return temp;
	}
}
</pre>
				
				That was quite a bit. Once you've mastered Java's syntax, move on to OOP.
				
      </div>
			
    </div><!-- /.container -->

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

    <script src="../dist/js/bootstrap.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../assets/js/ie10-viewport-bug-workaround.js"></script>
		
		<script>
		// Load this when the DOM is ready
		$(function(){
			$('#writing-table').dataTable();
			$('[data-toggle="tooltip"]').tooltip();
		});
		</script>
		
  </body>
</html>
